ID,Script Type,Script,Reference Document Type,Event Frequency,Cron Format,DocType Event,API Method,Allow Guest,Module (for export),Disabled,Enable Rate Limit,Request Limit,Time Window (Seconds)
FDA Recall,API,"# Server Script version - Frappe automatically parses JSON from requests
# No imports, no eval, no manual parsing needed

def check_inventory(recalls):
    """"""
    Cross-reference FDA recalls against ERPNext inventory
    
    Args:
        recalls: List of recall dicts (already parsed by Frappe)
    
    Returns:
        dict with matched_count and matches list
    """"""
    # recalls should already be a list/dict, no parsing needed
    if not recalls:
        return {'success': False, 'matched_count': 0, 'matches': []}
    
    matches = []
    
    for recall in recalls:
        recall_number = recall.get('recall_number')
        product_code = recall.get('product_code')
        code_info = recall.get('code_info', '')
        device_name = recall.get('device_name')
        
        # Extract UDI from code_info
        udi_numbers = extract_udi_from_code_info(code_info)
        
        # Check 1: Match Product Code against Item Names
        if product_code:
            item_matches = frappe.get_all(
                'Item',
                filters={'item_name': product_code},
                fields=['name', 'item_name']
            )
            
            for item in item_matches:
                # Check if already exists
                if not frappe.db.exists('Recall Match', {
                    'recall_number': recall_number,
                    'erpnext_item_code': item.name,
                    'match_type': 'Item Name Match'
                }):
                    match = create_recall_match(
                        recall=recall,
                        match_type='Item Name Match',
                        item_code=item.name,
                        item_name=item.item_name
                    )
                    matches.append(match)
        
        # Check 2: Match UDI against Batch Numbers
        if udi_numbers:
            for udi in udi_numbers:
                batch_matches = frappe.db.sql(""""""
                    SELECT name, item, batch_id
                    FROM `tabBatch`
                    WHERE batch_id LIKE %s
                """""", (f'%{udi}%',), as_dict=True)
                
                for batch in batch_matches:
                    # Get item name
                    item_name = frappe.db.get_value('Item', batch.item, 'item_name')
                    
                    # Check if already exists
                    if not frappe.db.exists('Recall Match', {
                        'recall_number': recall_number,
                        'erpnext_batch_number': batch.name,
                        'match_type': 'Batch UDI Match'
                    }):
                        match = create_recall_match(
                            recall=recall,
                            match_type='Batch UDI Match',
                            item_code=batch.item,
                            item_name=item_name,
                            batch_number=batch.name
                        )
                        matches.append(match)
    
    # Send email notification if matches found
    if matches:
        send_recall_notification(matches)
    
    frappe.db.commit()
    
    return {
        'success': True,
        'matched_count': len(matches),
        'matches': matches
    }

def extract_udi_from_code_info(code_info):
    """"""Extract UDI numbers from code_info text using simple string operations""""""
    if not code_info:
        return []
    
    udi_numbers = []
    text = str(code_info).upper()
    
    # Split by newlines and process each line
    for line in text.split('\n'):
        if 'UDI' in line or 'GTIN' in line:
            # Remove common separators and split
            clean_line = line.replace(':', ' ').replace('(', ' ').replace(')', ' ').replace(',', ' ')
            words = clean_line.split()
            
            # Look for numeric strings that are 10+ digits (likely UDI/GTIN)
            for word in words:
                # Remove non-digit characters
                digits = ''.join(c for c in word if c.isdigit())
                if len(digits) >= 10:
                    udi_numbers.append(digits)
    
    # Remove duplicates while preserving order
    seen = set()
    unique = []
    for udi in udi_numbers:
        if udi not in seen:
            seen.add(udi)
            unique.append(udi)
    
    return unique

def create_recall_match(recall, match_type, item_code, item_name, batch_number=None):
    """"""Create a Recall Match record""""""
    doc = frappe.get_doc({
        'doctype': 'Recall Match',
        'recall_number': recall.get('recall_number'),
        'fda_device_name': (recall.get('device_name', '') or '')[:140],
        'fda_product_code': (recall.get('product_code', '') or '')[:140],
        'match_type': match_type,
        'erpnext_item_code': item_code,
        'erpnext_item_name': item_name,
        'erpnext_batch_number': batch_number,
        'recall_date': recall.get('recall_date'),
        'recall_status': (recall.get('status', '') or '')[:140],
        'fda_reason': (recall.get('reason', '') or '')[:140],
        'notified': 0,
        'fda_recall_link': f'http://192.168.1.176/recall/{recall.get(""id"", """")}'
    })
    
    doc.insert(ignore_permissions=True)
    
    return {
        'name': doc.name,
        'recall_number': doc.recall_number,
        'item_code': doc.erpnext_item_code,
        'item_name': doc.erpnext_item_name,
        'batch_number': doc.erpnext_batch_number,
        'match_type': doc.match_type
    }

def send_recall_notification(matches):
    """"""Send email notification for recall matches""""""
    
    # Build email content
    message = f""""""
    <h2>FDA Recall Alert - Inventory Matches Found</h2>
    <p>{len(matches)} item(s) in your inventory match FDA recalls:</p>
    <table border=""1"" cellpadding=""5"" cellspacing=""0"">
        <tr>
            <th>Recall Number</th>
            <th>Match Type</th>
            <th>Item Code</th>
            <th>Item Name</th>
            <th>Batch Number</th>
        </tr>
    """"""
    
    for match in matches:
        message += f""""""
        <tr>
            <td>{match.get('recall_number', '')}</td>
            <td>{match.get('match_type', '')}</td>
            <td>{match.get('item_code', '')}</td>
            <td>{match.get('item_name', '')}</td>
            <td>{match.get('batch_number', 'N/A')}</td>
        </tr>
        """"""
    
    message += """"""
    </table>
    <p>Please review these items immediately in the FDA Recall Checker.</p>
    """"""
    
    # Send email
    frappe.sendmail(
        recipients=['gary.starr@surgishop.com'],
        subject=f'FDA Recall Alert - {len(matches)} Inventory Matches',
        message=message
    )
    
    # Mark as notified
    for match in matches:
        frappe.db.set_value('Recall Match', match['name'], 'notified', 1)

# Main execution
recalls_data = frappe.form_dict.get('recalls')
result = check_inventory(recalls_data)
frappe.response['message'] = result",,All,,Before Insert,check_recall_inventory,0,,0,0,5,86400
Delivery Note to Packing List,DocType Event,"# This function MUST be linked as a Custom Script or Server Script
# to run on the 'after_submit' event of the 'Delivery Note' DocType.


def create_fulfillment_documents(doc):
    # --- Configuration ---
    PRINTER_NAME = ""Brother_HL-L3210CW_series""
    PACKING_SLIP_DOCTYPE = ""Packing Slip""
    PRINT_FORMAT = ""Surgi Packing Slip""

    if doc.doctype != ""Delivery Note"" or doc.docstatus != 1:
        # Only show this if the hook is somehow misconfigured
        return

    dn = doc

    try:
        # Reload DN silently to ensure latest state
        dn = frappe.get_doc(""Delivery Note"", doc.name)
        frappe.log_error(message=f""Reloaded DN: {dn.name}"", title=""Debug: DN Reload Success"")
    except Exception as reload_err:
        frappe.msgprint(f""✗ Failed to reload Delivery Note {doc.name}. Error: {str(reload_err)}"", alert=True, indicator=""red"")
        frappe.log_error(message=str(reload_err), title=f""DN Reload Error for {doc.name}"")
        return

    # Check if the Packing Slip DocType exists (critical check)
    if not frappe.db.exists(""DocType"", PACKING_SLIP_DOCTYPE):
        frappe.msgprint(""✗ Packing Slip DocType not found! Check configuration."", alert=True, indicator=""red"")
        return

    try:
        packing_slip = frappe.new_doc(PACKING_SLIP_DOCTYPE)

        # Set REQUIRED fields (General)
        packing_slip.from_case_no = 1
        packing_slip.to_case_no = 1

        # --- MANDATORY HEADER MAPPING ---
        packing_slip.delivery_note = dn.name
        packing_slip.customer = dn.customer

        try:
            packing_slip.customer_name = dn.customer_name
        except Exception:
            packing_slip.customer_name = dn.customer

        packing_slip.naming_series = ""MAT-PAC-.YYYY.-""
        packing_slip.company = dn.company
        packing_slip.delivery_date = dn.delivery_date
        packing_slip.shipping_address_name = dn.shipping_address_name
        packing_slip.billing_address_name = dn.billing_address_name
        packing_slip.contact_person = dn.contact_person

        # Map items
        mapped_item_count = 0
        for dn_item in dn.items:
            dn_item_reference_name = dn_item.name

            if not dn_item_reference_name:
                error_msg = f""CRITICAL: Failed to retrieve unique name for item {dn_item.item_code} (idx: {dn_item.idx}). Cannot link to Packing Slip.""
                frappe.msgprint(error_msg, alert=True, indicator=""red"")
                continue

            ps_item = packing_slip.append(""items"", {})
            try:
                ps_item.dn_detail = dn_item_reference_name
                mapped_item_count += 1
            except Exception:
                frappe.msgprint(f""CRITICAL: Item {dn_item.item_code} failed to link. Field 'dn_detail' not found."", alert=True, indicator=""red"")
                frappe.log_error(f""Missing mandatory reference field 'dn_detail' on PS Item for {dn_item.item_code}"", ""PS Item Link Failure"")
                packing_slip.items.pop()
                continue

            ps_item.item_code = dn_item.item_code
            ps_item.item_name = dn_item.item_name
            ps_item.qty = dn_item.qty

            try:
                ps_item.description = dn_item.description
            except Exception:
                ps_item.description = """"

            try:
                ps_item.stock_uom = dn_item.stock_uom
            except Exception:
                ps_item.stock_uom = None

            try:
                ps_item.uom = dn_item.uom
            except Exception:
                ps_item.uom = None

            try:
                ps_item.warehouse = dn_item.warehouse
            except Exception:
                ps_item.warehouse = None

        if mapped_item_count == 0:
            frappe.msgprint(""✗ No items could be successfully mapped to the Packing Slip."", alert=True, indicator=""red"")
            return

        packing_slip.insert(ignore_permissions=True)

        # Submit the Packing Slip
        try:
            packing_slip.submit()
            
        except Exception as submit_err:
            error_details = str(submit_err)
            frappe.msgprint(f""✗ Packing Slip submission failed. Details: {error_details}"", alert=True, indicator=""red"")
            frappe.log_error(message=error_details, title=f""PS Submit Error for {packing_slip.name}"")
            return
            
        # --- Print the Submitted Packing Slip ---
        print_failed = False
        try:
            # Call the custom app function to print the Packing Slip
            frappe.call(
                ""surgi_print_dn.api.print_packing_slip_via_webhook"",
                doc_name=packing_slip.name,
                printer_name=PRINTER_NAME,
                print_format=PRINT_FORMAT # Pass the custom print format defined in the config
            )
        except Exception as print_err:
            error_details = str(print_err)
            print_failed = True
            # Log failure but do not return
            frappe.log_error(message=error_details, title=f""PS Print Error for {packing_slip.name}"")

        # --- FINAL SINGLE MESSAGE ---
        if print_failed:
            frappe.msgprint(
                f""✓ Packing Slip {packing_slip.name} created and submitted. ✗ WARNING: Print failed. Check Error Log for details."", 
                alert=True, indicator=""orange""
            )
        else:
            frappe.msgprint(
                f""✓ Packing Slip {packing_slip.name} created, submitted, and sent to printer."", 
                alert=True, indicator=""green""
            )


    except Exception as ps_err:
        frappe.msgprint(f""✗ Packing Slip creation failed. Error: {str(ps_err)}"", alert=True, indicator=""red"")
        frappe.log_error(message=str(ps_err), title=""Packing Slip Creation Error"")
        return

# Ensure the function is called
create_fulfillment_documents(doc)
",Delivery Note,All,,After Submit,,0,,0,0,5,86400
Sales Invoice Auto Send Setup,DocType Event,"""""""
Server Script: Sales Invoice - Auto Send Setup
Type: DocType Event
DocType: Sales Invoice
Event: Before Submit
""""""

# Skip auto-send for returns/credit notes
if not doc.is_return:
    # Calculate send time (24 hours from now) using frappe.utils
    send_time = frappe.utils.add_to_date(frappe.utils.now_datetime(), hours=24)
    
    # Set custom field values (we only need send_time and status)
    doc.custom_scheduled_send_time = send_time
    doc.custom_auto_send_status = 'Scheduled'
    
    frappe.msgprint(
        ""Invoice will be automatically sent to customer on "" + str(frappe.utils.format_datetime(send_time)),
        indicator='green',
        title='Auto-Send Scheduled'
    )",Sales Invoice,All,,Before Submit,,0,,0,0,5,86400
Send Pending Invoices,Scheduler Event,"""""""
Server Script: Send Pending Invoices
Type: Scheduler Event
Event: Hourly
""""""

def send_pending_invoices():
    """"""Check for invoices ready to be sent (24 hours have passed)""""""
    
    # Get all invoices scheduled for auto-send where send time has passed
    # Exclude returns/credit notes (is_return = 0)
    invoices = frappe.db.sql(""""""
        SELECT name, customer, customer_name, contact_email
        FROM `tabSales Invoice`
        WHERE docstatus = 1
        AND is_return = 0
        AND custom_auto_send_status = 'Scheduled'
        AND custom_scheduled_send_time IS NOT NULL
        AND custom_scheduled_send_time <= NOW()
    """""", as_dict=True)
    
    for invoice in invoices:
        try:
            send_invoice_email(invoice.name)
            
            # Update status
            frappe.db.set_value(
                'Sales Invoice',
                invoice.name,
                {
                    'custom_auto_send_status': 'Sent',
                    'custom_actual_send_time': frappe.utils.now_datetime()
                },
                update_modified=False
            )
            frappe.db.commit()
            
        except Exception as e:
            # Mark as failed and log error
            frappe.db.set_value(
                'Sales Invoice',
                invoice.name,
                'custom_auto_send_status',
                'Failed',
                update_modified=False
            )
            frappe.db.commit()
            
            frappe.log_error(
                message=""Invoice: "" + invoice.name + ""\nError: "" + str(e),
                title=""Failed to send invoice email""
            )

def send_invoice_email(invoice_name):
    """"""Send the invoice email with PDF attachment""""""
    
    # Get the invoice document
    invoice = frappe.get_doc('Sales Invoice', invoice_name)
    
    # Get customer email
    recipient = invoice.contact_email or frappe.db.get_value('Customer', invoice.customer, 'email_id')
    
    if not recipient:
        raise Exception(""No email found for customer "" + invoice.customer)
    
    # Email subject
    subject = ""Invoice "" + invoice.name + "" from SurgiShop""
    
    # Email body - UPDATE THIS WITH YOUR CUSTOM TEXT
    customer_name = invoice.customer_name or invoice.customer
    message = ""Dear "" + customer_name + "",\n\n""
    message = message + ""Please find attached invoice "" + invoice.name + "".\n\n""
    message = message + ""[YOUR CUSTOM EMAIL BODY WILL GO HERE]\n\n""
    message = message + ""Best regards,\nSurgiShop Accounting Team""
    
    # Generate PDF with custom print format
    print_format = ""Surgi Sales Invoice""
    
    # Get PDF content using frappe.utils.pdf
    pdf_content = frappe.utils.pdf.get_pdf(
        'Sales Invoice',
        invoice.name,
        print_format=print_format
    )
    
    # Send email with attachment
    frappe.sendmail(
        recipients=[recipient],
        sender=""accounting@surgishop.com"",
        subject=subject,
        message=message,
        attachments=[{
            'fname': invoice.name + '.pdf',
            'fcontent': pdf_content
        }],
        reference_doctype='Sales Invoice',
        reference_name=invoice.name
    )
    
    # Add comment to invoice
    invoice.add_comment(
        'Comment',
        'Invoice automatically sent to ' + recipient + ' via email'
    )

# Run the function
send_pending_invoices()",,Hourly,,Before Insert,,0,,0,0,5,86400
Sales Invoice Bounce Notification to Accounting,DocType Event,"# Alert Accounting AND log on Sales Invoice timeline
# Prevents duplicate alerts
# ERPNext v15 compatible (no bare return)

if (
    doc.reference_doctype == ""Sales Invoice""
    and doc.status in (""Error"", ""Not Sent"")
    and not doc.get(""custom_alert_sent"")
):

    invoice_name = doc.reference_name
    error_msg = doc.error or ""No error details provided""

    # 1️⃣ Log to Sales Invoice timeline
    try:
        frappe.get_doc(""Sales Invoice"", invoice_name).add_comment(
            ""Info"",
            f""""""
            <b>Email Delivery Failure</b><br>
            The invoice email failed or bounced.<br><br>
            <b>Error:</b><br>
            <pre>{frappe.utils.escape_html(error_msg)}</pre>
            """"""
        )
    except Exception as e:
        frappe.log_error(
            f""Failed to log email error to Sales Invoice {invoice_name}: {e}""
        )

    # 2️⃣ Email Accounting
    frappe.sendmail(
        recipients=[""accounting@surgishop.com""],
        subject=f""[ALERT] Sales Invoice Email Failed – {invoice_name}"",
        message=f""""""
        <p><b>Sales Invoice Email Failure</b></p>

        <p>
        The email for Sales Invoice <b>{invoice_name}</b> failed to send or bounced.
        </p>

        <p><b>Error Details:</b></p>
        <pre>{frappe.utils.escape_html(error_msg)}</pre>

        <p>
        Please verify the customer email address and resend the invoice.
        </p>
        """""",
        delayed=False
    )

    # 3️⃣ Mark alert as sent (prevents duplicates)
    doc.db_set(""custom_alert_sent"", 1, update_modified=False)
",Email Queue,All,,After Save,,0,,0,0,5,86400
Purchase Receipt allow blemish in received qty,DocType Event,"def execute(doc, method=None):
    flt = frappe.utils.flt

    total_blemish = 0.0
    total_rejected = 0.0
    total_received = 0.0

    for item in doc.items:
        qty_ordered = flt(item.get(""qty"") or 0)
        blemish = flt(item.get(""custom_blemish_quantity"") or 0)
        rejected = flt(item.get(""rejected_qty"") or 0)

        accepted = qty_ordered + blemish
        received = accepted + rejected

        item.qty = received
        item.accepted_qty = accepted
        item.received_qty = received

        total_blemish += blemish
        total_rejected += rejected
        total_received += received

    doc.custom_total_blemish_quantity = total_blemish
    doc.custom_total_rejected_quantity = total_rejected
    doc.custom_total_received = total_received",Purchase Receipt,All,,Before Validate,,0,,0,0,5,86400
Delivery Note to Sales Invoice,DocType Event,"# This script MUST be attached as a Server Script
# to run on the 'after_submit' event of the 'Delivery Note' DocType.
# It creates and submits the Sales Invoice only after the Delivery Note is finalized.

def create_sales_invoice(doc):
    # Ensure the document is a submitted Delivery Note
    if doc.doctype != ""Delivery Note"" or doc.docstatus != 1:
        return

    dn = doc

    # --- Create and Submit Sales Invoice ---
    try:
        # 1. Call the standard mapper to create the Sales Invoice dict from the Delivery Note
        # We pass BOTH the name (source_name) and the document object (source_doc) for maximum reliability.
        si_doc_dict = frappe.call(
            ""erpnext.stock.doctype.delivery_note.delivery_note.make_sales_invoice"",
            source_name=dn.name,  # Added the required positional argument
            source_doc=dn
        )

        if si_doc_dict and si_doc_dict.get('doctype') == 'Sales Invoice':
            # 2. Convert dict to DocType object, insert, and submit
            si = frappe.get_doc(si_doc_dict)
            si.insert(ignore_permissions=True)
            si.submit()

            # 3. Final success message
            frappe.msgprint(
                f""✓ Sales Invoice {si.name} automatically created and submitted."",
                alert=True,
                indicator=""green""
            )
        else:
            # Handle cases where the mapper returns something unexpected (e.g., already invoiced)
            frappe.msgprint(""✗ Sales Invoice creation skipped (DN likely already invoiced)."", alert=True, indicator=""orange"")

    except Exception as si_err:
        error_details = str(si_err)
        # Log failure
        frappe.msgprint(f""✗ Sales Invoice automation failed. Check Error Log. Details: {error_details}"", alert=True, indicator=""red"")
        frappe.log_error(message=error_details, title=f""SI Auto Creation Error for DN {dn.name}"")

# Ensure the function is called
create_sales_invoice(doc)
",Delivery Note,All,,After Submit,,0,,0,0,5,86400
Sales Order - Create Delivery Note,DocType Event,"# Emulate clicking ""Create → Delivery Note"" right after a Sales Order is submitted.
# Leaves the Delivery Note as a Draft and automatically prints it.

if doc.docstatus == 1:
    try:
        # Use the same backend method the button calls
        result = frappe.call(
            ""erpnext.sellling.doctype.sales_order.sales_order.make_delivery_note"",
            source_name=doc.name
        )

        # The mapper returns an unsaved DN as a dict
        if not result or not result.get(""items""):
            frappe.msgprint(""No deliverable items found, so no Delivery Note created."", alert=True)
        else:
            # Insert the PL as a new Draft document
            dn = frappe.get_doc(result)
            dn.insert(ignore_permissions=True)
            frappe.msgprint(
                f""Draft Delivery Note {dn.name} created from Sales Order {doc.name}."",
                alert=True, indicator=""green""
            )
            
            # Automatically print the Delivery Note using surgi_print_dn app
            # Silently attempt printing - don't show error if it fails
            try:
                printer_name = ""Brother_HL-L3210CW_series""
                frappe.call(
                    ""surgi_print_dn.api.print_delivery_note_via_webhook"",
                    doc_name=dn.name,
                    printer_name=printer_name
                )
                # Silent success - no popup needed
                frappe.logger().info(f""Auto-print successful for DN {dn.name}"")
            except:
                # Silent failure - no popup to confuse user
                frappe.logger().info(f""Auto-print attempted for DN {dn.name}"")
                
    except Exception as e:
        frappe.log_error(message=str(e), title=f""Auto DN creation failed for {doc.name}"")
        frappe.msgprint(""Auto Delivery Note creation failed — check Error Log."", alert=True, indicator=""red"") ",Sales Order,All,,After Submit,,0,,0,0,5,86400
